## Linux

netstat tcpdump ipcs

```
netstat -a
        -at
        -au
        -l
        -i
tcpdump
ipcs -m
     -q
     -s
ipcrm 
df
ps
        
```

共享内存

共享内存最大SHMMAX 最大内存段数**SHMMNI**

 内存空间 

![img](http://images.cnitblog.com/i/569008/201405/270929306664122.jpg)



**BSS段：**BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。
**数据段：**数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。
**代码段：**代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。
**堆（heap）：**堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）
**栈(stack)**：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。



### [动态链接与静态链接](http://blog.csdn.net/songjinshi/article/details/7383028)



## 线程与进程区别

- 进程是资源分配的基本单位，线程是cpu调度，或者说是程序执行的最小单位。

- 进程有独立的地址空间，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。当然，线程是拥有自己的局部变量和栈、寄存器的状态。

- 线程之间的通信比较方便，使用同步或互斥

  ​

## 内存管理机制



## EPOLL

**水平触发(level-triggered，也被称为条件触发)LT:** 只要满足条件，就触发一个事件(只要有数据没有被获取，内核就不断通知你)
**边缘触发(edge-triggered)ET:** 每当状态变化时，触发一个事件。



## Sizeof

**基本数据类型的sizeof **

**结构体的sizeof**

字节对齐：

1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；

2) 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）；

3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。



## Deque

索引map + 连续地址块



## 内存泄露

```
valgrind --tool=memcheck --leak-check=yes example1
```

## TCP

### 超时与重传

可靠传输：设定一个超时时间，超过后被认为数据没有传送到对方，重新再将数据发送。

重传定时器：使用指数退避函数设置每次超时时间，重要参数是往返测量时间RTT，RTT（Round Trip Time）由三部分组成：链路的传播时间（propagation delay）、末端系统的处理时间、
路由器缓存中的排队和处理时间（queuing delay），由于路由器缓存中的排队和处理时间会随着整个网络拥塞程度的变化而变化，故RTT估算值需要根据实时情况进行调整。

RTT采样测量方法：（1）TCP Timestamp选项，带有发送时的时间戳，RTT = 当前时间 -  数据包中Timestamp选项的回显时间。（2）重传队列中数据包的TCP控制块（数据结构，包含发送时间），但在发生重传时不能确定对方返回的确认是否是重传返回的还是第一次返回的，所以对重传的报文不计算RTT

RTO计算：由RTT估计值、RTT平均偏差值得出



## 连接建立







## 2MSL

1. 保证TCP协议的全双工连接能够可靠关闭，最后的ack有可能没有成功发送，当在MSL期间收到ack时，说明丢包，主动关闭方再次发送ack
2. 保证这次连接的重复数据段从网络中消失，丢弃期间收到的数据，防止在下次复用连接时之前的滞留的数据被误认。





