# 文件与IO
- 通用概念
  -  文件结构
  -  文件属性


 

-  文件操作 - 读
-  文件操作 - 写
     -  sync同步
     -  *文件锁
     -  *mmap

Linux中的File IO
- read、fread
- lock
- mmap

Java中的File IO
- IO
- NIO
- FileLock

## 权限

```bash
-rwxrw-r‐-1 root root 1213 Feb 2 09:39 abc
```

- 三种权限 r(4) w(2) x(1)，用数字代表权限，读4，读写6，全7
- 三种权限所有者 User、Group、Others
- 三个一组、分别代表User、Group、Others的权限

## 文件描述符

### 概念
文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，值是一个非负整数（通常是小整数），用于指代被打开的文件。每个进程默认有三个已定义的文件操作符：
- 0：标准输入
- 1：标准输出
- 2：标准错误

### 文件描述符与文件

<div align=center>![用户区和系统区](image/fileIO2.PNG)</div>

系统为每一个进程维护了一个文件描述符表。表中包含所有已打开的文件指针项，描述符即此表的索引。因此每一个文件描述符会通过文件指针与一个打开的文件相对应。不同的文件描述符**可能**会指向同一个文件。（一个进程多次打开同一个文件）相同的文件**可以**被不同的进程打开也可以在同一个进程中被多次打开。

文件描述符表中的文件指针会指向内核中名为file的数据结构体，也称打开文件句柄（open file handle），这些所有的文件句柄由系统同一管理，称为打开文件表。file数据结构中包含了
- 文件操作的上下文信息（如读写位置、模式等）。
- 指向下一抽象层的"文件"指针（隐藏了更多的文件组织的细节，逻辑上指向了一个文件内容）。
- 指向文件操作函数表的指针。指向文件操作函数表的指针会因为最终设备的不同而不同，实为设备的驱动程序。



进程可能通过`fork()`使得多个进程中的文件描述符指向了同一个打开文件句柄。因此，结构中会记录引用计数。

## 文件锁
Linux默认为协同锁，对未持锁的读写操作没有限制，锁的作用依靠程序自身参与锁检测完成。**不建议在Linux中启用强制锁。**


## 文件内存映射


## Linux I/O API

### 系统级API
`write(), read(), close(), open()`是系统级的文件操作API。


底层系统的IO操作是耗时操作，为了减少系统调用次数，系统一般划分为用户空间和内核空间。用户空间向上提供高层的**标准库API**，内部通过缓存实现减少向下对**系统调用**。

<div align=center>![用户区和系统区](image/fileIO1.PNG)</div>

在内核空间和用户空间（甚至是在程序空间，当自定义缓存时）都存在缓存区，以减少对下一层的调用。故必要时需要刷冲缓存区（`flush`），只确保缓冲全部送至下一层，**不确保**全部已写在最终设备文件上。


##### read() and write()
- 系统调用，通过文件指针读写。

##### pread() and pwrite()
- 系统调用，读时线程安全，以偏移量作为函数局部变量，不共享读写指针，故不改变读写指针。
- **不**解决多线程下的多写冲突、读写冲突
- 适合**随机访问（Random Access）**、**固定位置访问（Fixed Access）**、**多线程只读访问（Multithread Read Access）**


##### flock() lockf() and fcntl()
- 函数`lockf()`是`fcntl()`的封装，两者实际上等价。

- 在**Linux**中，`lockf()`与`flock(`)的锁之间没有影响性。即使其中一个进程对同一个文件设置了排他锁，另外一个使用另一个API也能设置排它锁。

- flock只能设置为全局锁，fcntl()可以对局部数据区域进行锁定。

- 函数`flock()`与`file`相关联，因此通过`fork()`产生的子进程会因为复制了指向同一个file结构的指针（fd）而继承了父进程的锁。此情况下，只有父子进程全部释放锁之后，其他进程才能再次获得锁。

- 建议只使用`fcntl()`进行文件锁操作，避免产生不必要的误解。

### 标准库API





## CFS

Linux进程调度算法

为了度量进程运行时间，提出虚拟运行时间(vruntime)，vruntime越大，说明该进程运行的越久，所以被调度的可能性就越小。

调度算法：每次选择vruntime值最小的进程进行调度

运行时间：分配给进程的运行时间 = 调度周期时间 * （进程权重 / 所有进程权重之和）  

vruntime更新方法：vruntime +=  delta * grow_rate = delta *  （NICE_0_LOAD/ se.weight）,  NICE0_LOAD / 1024 = 1

vruntime与delta成正比，vruntime与se.weight成反比

## 进程间通信-pipe

- 管道是一个固定大小的缓冲区
- 匿名管道只能由父子进程进行读写（fork）

## [IPC 之消息队列](http://blog.csdn.net/jiajiayouba/article/details/8815042)

## 进程与线程

- 进程：抽象程序，虚拟计算机资源，满足公平性（每个程序能被调度），效率（IO操作）
- 线程：同一个进程下的线程能够共享内存空间（**内存**）、共享文件描述符（**文件**）、共享进程资源（**CPU**）

[TBD]

- https://book.douban.com/subject/19973015/





## Readers–writers problem

关于资源读写并发的问题，典型如文件读写。

第一个解决的是并发读问题，在没有写操作时应当支持并发读取。关键点如下：

1. 写为**排斥锁**，写时其他其他读写操作阻塞，读为**共享锁**，**有一个以上读时阻塞写**。
2. 在读操作期间，当有新的读操作，会使读锁持有的时间增加，导致写操作滞后。称为**读优先**。

第二个解决的是写公平性问题，读操作应该在之前的写操作完成后进行，而不应该被后续读操作插队，关键点如下：

1. 声明一个试读锁，任何一个读操作之前先申请试读锁，获取后再获取读共享锁，再释放试读锁，其余按照读锁的语义进行。
2. 当一个写操作加入时，申请试读锁（把试读禁掉，不让后续读操作获取），之后再获取互斥锁处理协调其他写操作，仅当没有写操作时才将试读锁释放。
3. 在写操作期间，当有新的写操作，会使试读锁持有的时间增加，导致读操作滞后。称为**写优先**。

第三个解决的是确保读写公平性问题，读写操作应按照先进先出的队列进行。关键点如下：

1. 使用先进先出队列安排读写操作，在任何读写操作前均需进入队列，队列的作用是按照顺序获取读锁或写锁，获取后应该先出队再进行读写操作，排队排的是锁，不是操作，操作已经由相应的锁保证同步。

## Copy-on-Write

写时复制，是一种解决读写同步的一种手段，指在对数据进行写更新时，为该线程单独复制一份副本并在此副本进行修改操作，随后根据情况将更新的副本替换掉原来的数据，达到更新目的。

好处是，**支持多读和写并发**，在写操作进行时读操作仍可进行。**不支持并发写**。**不支持严格一致性**，对数据的修改不一定对之后的读可见，但一定确保最终数据进行了更新，即最终一致性。适用于读操作远多于写操作的情况，**内存开销较大**。

这也可作为一种**减少内存开销**的手段，例如`String`，不同对象中相同的字面值可以直接引用同一个对象，直到某个对象需要对字符串进行修改时，再复制一份副本给予修改。



## 事务四个级别

### Read uncommitted

- 问题->**脏读**：在一个事务处理过程里能够读取另一个未提交的事务中的数据。回滚时发生数据不一致。
- 问题->更新丢失。

### Read committed

- 限制：只允许看到提交了事务的数据
- 问题->**不可重复读**：事务期间发生了另一个事务的提交，导致对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值。
- 问题：更新丢失。

### Repeatable read

- 限制：在事务开启中，涉及到的读写的数据项不允许被其他事务进行更新操作。
- 问题->**幻读**：在事务中对某些范围查询结果不一致，期间有其他事务对其他数据进行插入操作。
- 问题：**更新丢失**：当一个数据更新的值需要依赖于修改前的值，而这两者的关系没有在更新语句中体现时（例如`set b = b + 1`就体现关系，而`set b = 2 + 1` 就没有，2是b更新前的值），将出现更新丢失的问题。在读取-更新之间，另一个事务对同一个数据进行了读取-更新并提交了事务。


### Serializable

- 限制：事务的执行时间段不存在交集。

### Repeatable read + MVCC = Snapshot Isolation Level



#### [Ref]

- https://msdn.microsoft.com/en-us/library/cc546518.aspx
- https://vladmihalcea.com/2014/09/14/a-beginners-guide-to-database-locking-and-the-lost-update-phenomena/




## 更新丢失（Lost Update）的解决方案

### 悲观锁 （Pessimistic Locking )

MySQL：

- 使用`for update`语句，在被读出的数据持互斥锁，不允许其他事务对待更新的数据进行读写。
- 使用SERIALIZE事务隔离级别。

Hibernate：

- 通过向Session或Query指定`LockMode = PESSIMISTIC_WRITE`获取写锁。

### 乐观锁 （Optimistic Locking）

原理：在表增加一个版本号字段，读取出数据时，将当前版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

Hibernate：通过增加一个版本号字段解决更新丢失的问题，对实体类新增一个`version`字段和`@Version`注解。当发生更新冲突时，将抛出`StaleStateException` 

## 事务传播级别

